////
// _Слайсы_ являются ключевым типом данных в Go, предоставляя
// более мощный интерфейс для последовательностей, чем массивы.
////

package main

import "fmt"

func main() {

	// В отличие от массивов, срезы набираются только элементами,
	// которые они содержат (а не количеством элементов).
	// Чтобы создать пустой фрагмент с ненулевой длиной, используйте
	// встроенную функцию `make`. Здесь мы делаем слайс элементов
	// типа `string` и длины `3` (изначально нулевой).
	s := make([]string, 3)
	fmt.Println("emp:", s)

	// Мы можем устанавливать значения и получить их
	// точно так же, как с массивами.
	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println("set:", s)
	fmt.Println("get:", s[2])

	// Функция `len` возвращает длину слайса (среза), как и ожидалось.
	fmt.Println("len:", len(s))

	// В дополнение к этим основным операциям, слайсы поддерживают еще
	// несколько функций, что делает их более функциональными, в отличие
	// от массивов. Одна из них - встроенная функция `append`, который
	// возвращает слайс (срез), содержащий одно или несколько новых значений.
	// Обратите внимание, что нам нужно принять возвращаемое значение
	// из `append`, так как мы можем получить новое значение слайса (среза).
	s = append(s, "d")
	s = append(s, "e", "f")
	fmt.Println("apd:", s)

	// Слайсы (срезы) также могут быть скопированы при потощи функции `copy`.
	// Здесь мы создаем пустой кусок `c` той же длины, что и `s`, и копируем
	// в `c` из `s`.
	c := make([]string, len(s))
	copy(c, s)
	fmt.Println("cpy:", c)

	// Слайсы поддерживают оператор "slice" с синтаксисом `slice [low:high]`.
	// Например, слайс ниже получает фрагмент элементов `s[2]`, `s[3]` и `s[4]`.
	l := s[2:5]
	fmt.Println("sl1:", l)

	// Этот слайс разрезается до `s[4]` (исключая `s[5]`).
	l = s[:5]
	fmt.Println("sl2:", l)

	// И это ломтик от `s[2]` и до конца.
	l = s[2:]
	fmt.Println("sl3:", l)

	// Мы можем объявить и инициализировать переменную слайса одной строкой.
	t := []string{"g", "h", "i"}
	fmt.Println("dcl:", t)

	// Слайсы могут быть составлены в многомерные структуры данных. Длины
	// внутренних срезов могут варьироваться, в отличие от многомерных массивов.
	twoD := make([][]int, 3)
	for i := 0; i < 3; i++ {
		innerLen := i + 1
		twoD[i] = make([]int, innerLen)
		for j := 0; j < innerLen; j++ {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD)
}

// --- --- --- --- ---

// Обратите внимание, что слайсы являются иным, в отличие от массивов
// типом данных, но отображаются аналогично `fmt.Println`.

// $ go run slices.go
// emp: [  ]
// set: [a b c]
// get: c
// len: 3
// apd: [a b c d e f]
// cpy: [a b c d e f]
// sl1: [c d e]
// sl2: [a b c d e]
// sl3: [c d e f]
// dcl: [g h i]
// 2d:  [[0] [1 2] [2 3 4]]

// Проверьте эту замечательную публикацию в блоге (http://blog.golang.org/2011/01/go-slices-usage-and-internals.html)
// команды Go для получения более подробной информации о дизайне и
// реализации слайсов в Go.

// Теперь, когда мы увидели массивы и слайса, мы рассмотрим другую
// встроенную структуру данных Go: map.
